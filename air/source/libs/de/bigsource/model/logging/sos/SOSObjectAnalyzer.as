/** * $Id$ * $Date$ * Source by BigSource Alexander Funke und Kim Christiansen GbR * Visit blog.bigsource.de for updates and more free code. * Please contact info@bigsource.de for more information. *//** * Copyright (c) 2008 BigSource Alexander Funke und Kim Christiansen GbR *  * Permission is hereby granted, free of charge, to any person  * obtaining a copy of this software and associated documentation  * files (the "Software"), to deal in the Software without  * restriction, including without limitation the rights to use,  * copy, modify, merge, publish, distribute, sublicense, and/or sell  * copies of the Software, and to permit persons to whom the  * Software is furnished to do so, subject to the following conditions: *  * The above copyright notice and this permission notice shall be  * included in all copies or substantial portions of the Software. *  * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,  * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES  * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND  * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT  * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,  * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING  * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR  * OTHER DEALINGS IN THE SOFTWARE. */package de.bigsource.model.logging.sos {	import de.bigsource.model.logging.sos.SOSFoldMessage;	import flash.utils.describeType;		import de.bigsource.model.logging.LogItem;		public class SOSObjectAnalyzer {
		private static var _maxDepth : Number = 6;		private static var _indent : String = "\t";		public function SOSObjectAnalyzer() {		}		public static function getFoldMessage(p_item : LogItem) : SOSFoldMessage {			var m : SOSFoldMessage = new SOSFoldMessage();			var datatype : String = typeof(p_item.data);						switch(datatype) {				case "string":					m.title = String(p_item.data);					m.message = convertObject(p_item, 0);					break;				case "boolean":					m.title = String(p_item.data);					m.message = convertObject(p_item, 0);					break;				case "number":					m.title = String(p_item.data);					m.message = convertObject(p_item, 0);					break;				default:					m.title = "object";					m.message = convertObject(p_item, 0);					break;			}											return m;		}				public static function set maxDepth(value : Number) : void { 			_maxDepth = (_maxDepth > 255) ? 255 : value; 		}		public static function get maxDepth() : Number { 			return _maxDepth;		}		public static function convertObject(p_obj : *,depth : Number) : String {			var xml : XML = describeType(p_obj);			var txt : String = "";			//txt += xml.toXMLString();			var type : String = xml.@name;			var stringifyObj : Boolean = false;			var analyze : Boolean = true;					if(type == "String") {				// STRING				txt += "\"" + p_obj + "\"";			} else if(type == "Boolean" || type == "Number" || type == "int" || type == "uint") {				// BOOLEAN / NUMBER				txt += String(p_obj);			} else if(type == "undefined" || type == "null") {				// UNDEFINED / NULL				txt += "(" + type + ")";			} else {				// OBJECT						if(type == "Array") {					// ARRAY					type = "array";					analyze = true;					stringifyObj = false;//				} else if(type == "Button") {					// BUTTON//					type = "button";//					stringifyObj = true;				} else if(type == "Date") {					// DATE					type = "date";					analyze = false;					stringifyObj = true;				} else if(type == "MovieClip") {					// MOVIECLIP					type = "movieclip";					stringifyObj = true;				} else if(type == "XML") {					// XML					type = "xml";					analyze = false;					stringifyObj = true;				} else if(type == "XMLNode") {					// XML					type = "xmlnode";					analyze = false;					stringifyObj = true;				} else if(type == "de.bigsource.logging::LogItem") {					// LogItem					type = "logitem";					analyze = true;					stringifyObj = false;				}							txt += "(";				if (type == "Object") {					txt += String(p_obj);				} else if (type == "Array") {					txt += "array[" + p_obj["length"] + "]";				} else {					txt += type;				}				txt += ") ";							if(stringifyObj) {					if(type == "XML"){						txt += p_obj.toXMLString();					} else {						txt += p_obj.toString();					}				}							if(analyze && depth <= _maxDepth) {					var txtProps : String = "";										var variables : XMLList = xml..variable;					for each(var xmlprop: XML in variables) {						if(!(type == "logitem" && xmlprop.@name == "functionname" && p_obj[xmlprop.@name] == null || type == "logitem" && xmlprop.@name == "lineNumber" && p_obj[xmlprop.@name] == 0 || type == "logitem" && xmlprop.@name == "fileName" && p_obj[xmlprop.@name] == null)){							txtProps += "\n" + multiply(_indent, (depth + 1)) + xmlprop.@name + ":" + convertObject(p_obj[xmlprop.@name], (depth + 1));						}					}										for(var prop:* in p_obj) {						txtProps += "\n" + multiply(_indent, (depth + 1)) + prop + ":" + convertObject(p_obj[prop], (depth + 1));					}									if(txtProps.length > 0) {						txt += "{" + txtProps + "\n" + multiply(_indent, depth) + "}";					}				}			}			return txt;		}		private static function multiply(str : String, n : Number) : String {			var ret : String = "";			var i : Number = 0;					while(i < n) {				ret += str;				i++;			}			return ret;		}	}}
